行为类模式包括[责任链模式](11.%20责任链模式.md)、[命令模式](10.%20命令模式.md)、[解释器模式](22.%20解释器模式.md)、迭代器模式、[中介者模式](9.%20中介者模式.md)、备忘录模式、观察者模式、[状态模式](21.%20状态模式.md)、[策略模式](13.%20策略模式.md)、[模板方法模式](5.%20模板方法模式.md)、[访问者模式](20.%20访问者模式.md)。

#### 策略模式与命令模式

策略模式的意图是封装算法，它认为“算法”已经是一个完整的、不可拆分的原子业务，即其意图是让这些算法独立，并且可以相互替换，让行为的变化独立于拥有行为的客户；而命令模式则是对动作的解耦，把一个动作的执行分为执行对象、执行行为，让两者相互独立而不相互影响。

**区别**

* 关注点不同。策略模式关注的是算法的完整性、封装性，只有具备了这两个条件才能保证其可以自由切换；命令模式则关注的是解耦问题。
* 角色功能不同。策略模式中的具体算法是负责一个完整算法逻辑，它是不可拆分的原子业务单元，一旦变更就是对算法整体的变更；而命令模式关注的是命令的实现，也就是功能的实现。
* 使用场景不同。策略模式适用于算法要求变换的场景；而命令模式适用于解耦两个有紧耦合关系的对象场合或者多命令多撤销的场景。

#### 策略模式与状态模式

**策略模式通用类图**

![](27.%20行为类模式比较/1.png)

**状态模式通用类图**

![](27.%20行为类模式比较/2.png)

策略模式与状态模式都是通过`Context`类封装一个具体的行为，都提供了一个封装的方法，是高扩展性的设计模式。但策略模式封装的是不同的算法，算法之间没有交互，以达到算法可以自由切换的目的；而状态模式封装的是不同的状态，以达到状态切换行为随之发生改变的目的。

**区别**

* 环境角色的职责不同。策略模式的环境角色只是一个委托作用，负责算法的替换；而状态模式的环境角色不仅仅是委托行为，它还具有登记状态变化的功能，与具体的状态类协作，共同完成状态切换行为随之切换的任务。
* 解决问题的重点不同。策略模式将内部算法的改变对外界的影响降低到最小，它保证的是算法可以自由地切换；而状态模式旨在解决内在状态的改变而引起行为改变的问题。
* 解决问题的方法不同。策略模式只是确保算法可以自由切换，但是什么时候用什么算法它决定不了；而状态模式封装了状态的变化而暴露了不同的行为或行为结果。
* 应用场景不同。策略模式只是一个算法的封装，可以是一个有意义的对象，也可以是一个无意义的逻辑片段，它是一系列平行的、可相互替换的算法封装后的结果；状态模式则要求有一系列状态发生变化的场景，它要求的是有状态且有行为的场景，也就是一个对象必须具有二维（状态和行为）描述才能采用状态模式，如果只有状态而没有行为，则状态的变化就失去意义。
* 复杂度不同。通常策略模式比较简单，这里的简单指的是结构简单，扩展比较容易，而且代码也容易阅读；而状态模式则通常比较复杂，因为它要从两个角色看到一个对象状态和行为的改变。

#### 观察者模式与责任链模式

在观察者模式中，一个具体的角色既可以是观察者，也可以是被观察者，这样就形成了一个观察者链。这与责任链模式非常类似，它们都实现了事务的链条化处理。

**区别**

* 链中的消息对象不同。责任链模式基本上不改变消息对象的结构，虽然每个节点都可以参与消费（一般是不参与消费）；但是在触发链模式中，链中传递的对象可以自由变化，只要上下级节点对传递对象了解即可，它不要求链中的消息对象不变化，它只要求链中相邻两个节点的消息对象固定。
* 上下节点的关系不同。在责任链模式中，上下节点没有关系，都是接收同样的对象，所有传递的对象都是从链首传递过来，上一节点是什么没有关系，只要按照自己的逻辑处理就成；而触发链模式的上下级关系很亲密，链中的任意两个相邻节点都是一个牢固的独立团体。
* 消息的分销渠道不同。在责任链模式中，一个消息从链首传递进来后，就开始沿着链条向链尾运动，方向是单一的、固定的；而触发链模式由于采用观察者模式，具有非常大的灵活性，一个消息传递到链首后，具体怎么传递是不固定的，可以以广播方式传递，也可以以跳跃方式传递，这取决于处理消息的逻辑。